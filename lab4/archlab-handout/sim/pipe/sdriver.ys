#######################################################################
# Test for copying block of size 4;
#######################################################################
	.pos 0
main:	irmovl Stack, %esp  	# Set up stack pointer
	irmovl Stack, %ebp  	# Set up base pointer

	# Set up arguments for copy function and then invoke it
	irmovl 4, %eax		# src and dst have 4 elements
	pushl %eax
	irmovl dest, %eax	# dst array
	pushl %eax
	irmovl src, %eax	# src array
	pushl %eax
	call ncopy		 
	halt			# should halt with num nonzeros in %eax
#/* $begin ncopy-ys */
##################################################################
# ncopy.ys - Copy a src block of len ints to dst.
# Return the number of positive ints (>0) contained in src.
#
##################################################################
# Do not modify this portion
# Function prologue.
ncopy:  pushl %ebp    # Save old frame pointer
  rrmovl %esp,%ebp  # Set up new frame pointer
  pushl %esi    # Save callee-save regs
  pushl %ebx
  pushl %edi
  mrmovl 8(%ebp),%ebx  # src
  mrmovl 16(%ebp),%edx  # len
  mrmovl 12(%ebp),%ecx  # dst

##################################################################
# You can modify this portion
  # Loop header
  xorl %eax,%eax    # count = 0;
  andl %edx, %edx
  jle Done
  iaddl $-4, %edx       # len = len - 4 
  jl endElems

unRolledLoop:  
  mrmovl (%ebx), %esi     # read val from src[0] or multiple
  mrmovl 4(%ebx), %edi   # read val from src[1] or multiple
  rmmovl %esi, (%ecx)     # store src[0] to dest[0] or multiple
  andl %esi, %esi       # check src[0] > 0 
  jle Npos1         # if so, goto Npos1:
  iaddl $1, %eax       # count++

Npos1:
  rmmovl %edi, 4(%ecx)    #store src[1] in dest[1] or multiple
  andl %edi, %edi        #check src[1] > 0 
  jle Npos2          #if not get the next element
  iaddl $1, %eax        #count++
  
Npos2:
  mrmovl 8(%ebx), %esi    #read val from src[2] or multiple
  mrmovl 12(%ebx), %edi    #read val from src[3] or multiple
  rmmovl %esi, 8(%ecx)    #store val from src[2] in dest[2] or multiple
  andl %esi, %esi        #check src[2] > 0 
  jle Npos3          #if not get the next element
  iaddl $1, %eax        #count++
  
Npos3:
  rmmovl %edi, 12(%ecx)  #store val froms src[3] in dest[3] or multiple
  andl %edi, %edi      #check src[3] > 0 
  jle Check        #if not get the next element
  iaddl $1, %eax      #count++

Check: 
  iaddl $16 , %ebx    #get to the next four positions of src
  iaddl $16 , %ecx     #get to the next four positions of dest
  iaddl $-4, %edx      # len = len - 4
  jge unRolledLoop    #if there is still 4|count loop again

endElems:
  iaddl $4, %edx       #add 4 back to get the actual len  
  
Rest1:
  iaddl $-1 , %edx
  jl Done          #short circuit
  mrmovl (%ebx), %esi    # read val from src...
  mrmovl 4(%ebx), %edi  # read val from src...
  rmmovl %esi, (%ecx)
  andl %esi, %esi
  jle Rest2
  iaddl $1, %eax
  
Rest2:
  iaddl $-1 , %edx
  jl Done  
  rmmovl %edi, 4(%ecx)
  andl %edi, %edi
  jle Rest3
  iaddl $1, %eax

Rest3:
  iaddl $-1 , %edx
  jl Done
  mrmovl 8(%ebx), %esi  # read val from src...
  rmmovl %esi, 8(%ecx)
  andl %esi, %esi
  jle Done
  iaddl $1, %eax  

##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
  popl %edi               # Restore callee-save registers
  popl %ebx
  popl %esi
  rrmovl %ebp, %esp
  popl %ebp
  ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end ncopy-ys */
#################################################################### 
# Epilogue code for the correctness testing driver
####################################################################

###############################
# Source and destination blocks 
###############################
	.align 4
src:	.long 0
	.long 1
	.long 2
	.long 3
	.long 4
	.long 5
	.long 6
	.long 7
	.long 8
	.long 9
	.long 10
	.long 11
	.long 12
	.long 13
	.long 14
	.long 15
	.long 16
	.long 17
	.long 18
	.long 19
	.long 20
	.long 21
	.long 22
	.long 23
	.long 24
	.long 25
	.long 26
	.long 27
	.long 28
	.long 29
	.long 30
	.long 31
	.long 32
	.long 33
	.long 34
	.long 35
	.long 36
	.long 37
	.long 38
	.long 39
	.long 40
	.long 41
	.long 42
	.long 43
	.long 44
	.long 45
	.long 46
	.long 47
	.long 48
	.long 49
	.long 50
	.long 51
	.long 52
	.long 53
	.long 54
	.long 55
	.long 56
	.long 57
	.long 58
	.long 59
	.long 60
	.long 61
	.long 62
	.long 63
        .long 0x0f0f0f0f # This shouldn't get moved

	.align 16
dest:	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xbeef
	.long 0xdeadbeef

.align 4
# Run time stack
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
	.long 0
Stack:
